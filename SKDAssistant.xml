<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- MuClient version 5.07-pre -->
<!-- Plugin "SKDAssistant" generated by Plugin Wizard -->

<muclient>

    <!-- Include standard constants -->
    <include name="constants.lua"/>
	
    <plugin
        name="SKDAssistant"
        author="Kanaye"
        id="2558d613791a941bb5f1898b"
        language="Lua"
        purpose="A plugin to help you conquer SKD"
        date_written="2024-7-24 17:59:57"
        save_state="y"
        requires="5.07"
        version="1.24"
    >
        <description trim="y">
            <![CDATA[ 
            
--------------------------[SKD Assistant Helpfile]--------------------------

skda                      Turn on/off certain parts
skda channel x            Change channel for the broadcasts 
skda help                 Outputs the helpfile of this plugin

-------------------------[SKD Assistant Weapons]--------------------------

skda lilac x              Set the ID of lilac main weapon
skda lilacdual x          Set the ID of lilac offhand weapon
skda lilacspell x         Set the ID of lilac attack*

Vulnerable to: Slash, Sonic, Electric, Air, Holy, Acid or Negative

skda cerulean x           Set the ID of cerulean main weapon
skda ceruleandual x       Set the ID of cerulean offhand weapon
skda ceruleanspell x      Set the ID of cerulean attack*

Vulnerable to: Light, Bash, Energy, Fire or Earth

skda seafoam x            Set the ID of seafoam main weapon
skda seafoamdual x        Set the ID of seafoam offhand weapon
skda seafoamspell x       Set the ID of seafoam attack*

Vulnerable to: Mental, Magic, Pierce, Cold, Shadow or Water

skda bag (x)              Set/Show the ID of the bag holding the weapons
skda shield x             Set the ID of your shield
skda hold x               Set the ID of your hold

* this can be any skill or spell. For example 'c 362' or 'backstab'.

-------------------------[SKD Assistant Commands]--------------------------

lizstop                   Manually stops Lizaan timer if needed
pylstop                   Manually stops Pylon timer if needed
cc                        Alias to attack pylon after weapon swap
ml                        Alias to broadcast good moonlight location
fc                        Alias to load, aim and fire cannon at ceiling*
fcc                       Alias to load, aim and fire cannon at floor*

* these commands will run you back to the cannon and fire it.

-------------------------[SKD Assistant Helpfile]--------------------------
            
            ]]>
        </description>  
    </plugin>

    <!--  Aliases for the plugin  -->
    <aliases>
    
        <!-- Define the alias for HELP FILE -->
        <alias
            match="^skda\shelp$"
            enabled="y"
            omit_from_output="n"
            regexp="y"
            sequence="100"
            script="OnHelp"
        />
    
        <!-- Define the alias for PLUGIN STATE -->
        <alias
            match="^skda$"
            name="ToggleOnSKDA"
            enabled="y"
            omit_from_output="n"
            regexp="y"
            sequence="100"
            script="ToggleSKDA"
        />

        <!-- Define the alias for CHANGE CHANNEL -->
        <alias
            match="^skda\schannel\s(.*?)$"
            name="SetChannel"
            group="SKDA"
            enabled="y"
            omit_from_output="n"
            regexp="y"
            sequence="100"
            script="SetChannel"
        />
		    
        <!-- Define the alias to set ID LILAC MAIN -->
        <alias
            match="^skda\slilac\s(.*?)$"
            name="setskdlilac"
            enabled="y"
            group="SKDA"
            omit_from_output="n"
            regexp="y"
            sequence="100"
            script="SetLilac"
        />
    
        <!-- Define the alias to set ID LILAC DUAL -->
        <alias
            match="^skda lilacdual\s(.*?)$"
            name="setskdlilacdual"
            enabled="y"
            group="SKDA"
            omit_from_output="n"
            regexp="y"
            sequence="100"
            script="SetLilacDual"
        />
    
        <!-- Define the alias to set ID LILAC ATTACK -->
        <alias
            match="^skda\slilacspell\s(.*?)$"
            name="setskdlilacspell"
            enabled="y"
            group="SKDA"
            omit_from_output="n"
            regexp="y"
            sequence="100"
            script="SetLilacSpell"
        />
    
        <!-- Define the alias to set ID CERULEAN MAIN -->
        <alias
            match="^skda\scerulean\s(.*?)$"
            name="setskdcerulean"
            enabled="y"
            group="SKDA"
            omit_from_output="n"
            regexp="y"
            sequence="100"
            script="SetCerulean"
        />
    
        <!-- Define the alias to set ID CERULEAN DUAL -->
        <alias
            match="^skda ceruleandual (.*?)$"
            name="setskdceruleandual"
            enabled="y"
            group="SKDA"
            omit_from_output="n"
            regexp="y"
            sequence="100"
            script="SetCeruleanDual"
        />
    
        <!-- Define the alias to set ID CERULEAN ATTACK -->
        <alias
            match="^skda\sceruleanspell\s(.*?)$"
            name="setskdceruleanspell"
            enabled="y"
            group="SKDA"
            omit_from_output="n"
            regexp="y"
            sequence="100"
            script="SetCeruleanSpell"
        />
    
        <!-- Define the alias to set ID SEAFOAM MAIN -->
        <alias
            match="^skda\sseafoam\s(.*?)$"
            name="setskdseafoam"
            enabled="y"
            group="SKDA"
            omit_from_output="n"
            regexp="y"
            sequence="100"
            script="SetSeafoam"
        />
    
        <!-- Define the alias to set ID SEAFOAM DUAL -->
        <alias
            match="^skda\sseafoamdual\s(.*?)$"
            name="setskdseafoamdual"
            enabled="y"
            group="SKDA"
            omit_from_output="n"
            regexp="y"
            sequence="100"
            script="SetSeafoamDual"
        />
    
        <!-- Define the alias to set ID SEAFOAM ATTACK -->
        <alias
            match="^skda\sseafoamspell\s(.*?)$"
            name="setskdseafoamspell"
            enabled="y"
            group="SKDA"
            omit_from_output="n"
            regexp="y"
            sequence="100"
            script="SetSeafoamSpell"
        />
    
        <!-- Define the alias to set ID SKD BAG -->
        <alias
            match="^skda\sbag\s(.*?)$"
            name="setskdbag"
            enabled="y"
            group="SKDA"
            omit_from_output="n"
            regexp="y"
            sequence="100"
            script="SetContainerSKD"
        />
    
        <!-- Define the alias for SHOW ID SKD BAG -->
        <alias
            match="^skda\sbag$"
            name="showskdbag"
            enabled="y"
            group="SKDA"
            omit_from_output="n"
            regexp="y"
            sequence="100"
            script="ShowContainerSKD"
        />
    
        <!-- Define the alias to set ID SKD SHIELD -->
        <alias
            match="^skda\sshield\s(.*?)$"
            name="setskdshield"
            enabled="y"
            group="SKDA"
            omit_from_output="n"
            regexp="y"
            sequence="100"
            script="SetShieldSKD"
        />
    
        <!-- Define the alias to set ID SKD HOLD -->
        <alias
            match="^skda\shold\s(.*?)$"
            name="setskdhold"
            enabled="y"
            group="SKDA"
            omit_from_output="n"
            regexp="y"
            sequence="100"
            script="SetHoldSKD"
        />
    
        <!-- Define the alias for aiming the cannon to ceiling -->
        <alias
            match="^fc"
            enabled="y"
            group="SKDA"
            regexp="y"
            sequence="200"
            script="CannonCeiling"
        />
    
        <!-- Define the alias for aiming the cannon to floor -->
        <alias
            match="^fcc"
            enabled="y"
            group="SKDA"
            regexp="y"
            sequence="200"
            script="CannonFloor"
        />
    
        <!-- Define the alias for reporting GOOD MOONLIGHT -->
        <alias
            match="^ml$"
            enabled="y"
            group="SKDA"
            regexp="y"
            sequence="200"
            script="GoodMLTrigger"
        />
    
        <!-- Define the alias to manually STOP LIZAAN TIMER if needed -->
        <alias
            match="^lizstop$"
			name="LizDeath"
            enabled="y"
            group="SKDA"
            regexp="y"
            sequence="200"
            script="LizaanTimerStop"
        />
    
        <!-- Define the alias to manually STOP PYLON TIMER if needed -->
        <alias
            match="^pylstop$"
            enabled="y"
            group="SKDA"
            regexp="y"
            sequence="200"
            script="PylonTimerStop"
        />
    
        <!-- Alias for checking update -->
        <alias
          match="^skda\supdate\scheck$"
          enabled="y"
          regexp="y"
          sequence="99"
          script="update_check_alias"
        />
        
        <!-- Alias for installing update -->
        <alias
          match="^skda\supdate\sinstall$"
          enabled="y"
          regexp="y"
          sequence="99"
          script="update_install_alias"
        />   
    
    </aliases>
	
	<!-- Triggers for the plugin. -->
    <triggers>
    
        <!-- Triggers for MINI BOSSES -->

        <!-- Trigger for LIZAAN SPAWN -->
        <trigger
            match="^.*Lizaan, the Drowned One, guards the Grey Halls.$"
            name="LizaanTrigger"
            enabled="y"
            group="SKDA"
            omit_from_output="n"
            regexp="y"
            sequence="100"
            script="LizaanTimer"
        />
	    
        <!-- Trigger for LIZAAN EXPLOSION -->
        <trigger
            name="LizaanExplosion"
            match="^Lizaan, the Drowned One's bloated eruption does UNBELIEVABLE things to you!.*$"
            enabled="y"
            group="SKDA"
            regexp="y"
            send_to="12"
            ignore_case="y"
            sequence="100"
            script="LizaanExplosion"
        />
       
        <!-- Trigger for LIZAAN DEATH -->
        <trigger
            match="^Lizaan.*(?:\bis DEAD\b|\bis battered to death\b|\blightning destroys\b|\bmind is destroyed\b|\bdamned forever\b|\bacid consumes\b|\blast spark of life is drained\b|\bturns deadly pale and collapses\b|\bfrozen to death\b|\bflames engulf\b|\bdestroyed by the blast\b|\bfinal deadly slash\b|\bforce of the water\b)|The voice of god has cleansed Lizaan.*$|The very fabric of the world rejects Lizaan.*$"			
            name="LizaanSpawn"
            enabled="y"
            group="SKDA"
            omit_from_output="n"
            regexp="y"
            sequence="100"
            script="LizaanTimerStop"
        />
    
        <!-- Triggers for PYLON PHASE -->
    
        <!-- Trigger for PYLON WEAPONS -->
        <trigger
            match=".*crystal pylon stands several spans above your head, glowing faintly.$"
            name="PylonColorsTrigger"
            enabled="y"
            omit_from_output="n"
            regexp="y"
            group="SKDA"
            sequence="100"
            script="PylonColorsTrigger"
        />
    
        <!-- Trigger for PYLON PHASE CONFIRM -->
        <trigger
            name="PylonSpawnTrigger"
            match="^You hear a low, ominous hum and see a crystal pylon.*$"
            enabled="y"
            group="SKDA"
            regexp="y"
            send_to="12"
            ignore_case="y"
            sequence="100"
            script="PylonSpawnTrigger"
        />
    
        <!-- Trigger for PYLON EXPLOSION -->
        <trigger
            name="PylonExplosion"
            match="^A crystal pylon erupts into hundreds of fragments that cut you to ribbons!.*$"
            enabled="y"
            group="SKDA"
            regexp="y"
            send_to="12"
            ignore_case="y"
            sequence="100"
            script="PylonExplosion"
        />
        
        <!-- Trigger for CANNON REPORT -->
        <trigger
            name="CannonReportTrigger"
            match="^.*A reverse spirit discombobulator cannon sort of contraption device is mounted on a rusted tripod.$"
            enabled="y"
            group="SKDA"
            regexp="y"
            send_to="12"
            ignore_case="y"
            sequence="100"
            script="CannonReportTrigger"
        />
    
        <!-- Trigger for CANNON SPAWN -->
        <trigger
            name="CannonSpawnTrigger"
            match="^You see a reverse spirit discombobulator cannon fade into existence before your eyes.$"
            enabled="y"
            group="SKDA"
            regexp="y"
            send_to="12"
            ignore_case="y"
            sequence="100"
            script="CannonSpawnTrigger"
        />
    
        <!-- Trigger for CANNON HIT -->
        <trigger
            name="CannonHitTrigger"
            match="^The blast hits the Sea King squarely in the body!$"
            enabled="y"
            group="SKDA"
            regexp="y"
            send_to="12"
            ignore_case="y"
            sequence="100"
            script="CannonHitTrigger"
        />
    
        <!-- Trigger for CANNON DIRECT HIT -->
        <trigger
            name="DirectHitTrigger"
            match="^A direct hit! The blast slams into the Sea King and sends him skidding across the ceiling!$"
            enabled="y"
            group="SKDA"
            regexp="y"
            send_to="12"
            ignore_case="y"
            sequence="100"
            script="DirectHitTrigger"
        />
    
        <!-- Trigger for CANNON MISS -->
        <trigger
            name="CannonMissTrigger"
            match="^The Sea King dances out of the way at the last moment.$"
            enabled="y"
            group="SKDA"
            regexp="y"
            send_to="12"
            ignore_case="y"
            sequence="100"
            script="CannonMissTrigger"
        />
    
        <!-- Triggers for TAUNT PHASE -->
    
        <!-- Trigger for AGGRO -->
        <trigger
            name="AggroTrigger"
            match="^Suddenly, the Sea King is before you. His appearance is just a distraction - a greatsword materializes overhead, and gravity takes hold!.*|^Suddenly, the Sea King is before you. A greatsword materializes in his hand and comes crashing down on your head!.*"
            enabled="y"
            group="SKDA"
            regexp="y"
            send_to="12"
            ignore_case="y"
            sequence="100"
            script="AggroTrigger"
        />
    
        <!-- Trigger for TAUNT HIT -->
        <trigger
            name="TauntHitTrigger"
            match="^As the Sea King approaches, moonlight grazes his shoulder.$"
            enabled="y"
            group="SKDA"
            regexp="y"
            send_to="12"
            ignore_case="y"
            sequence="100"
            script="TauntHitTrigger"
        />
    
        <!-- Trigger FOR SUCCESFUL PLAYER TAUNT -->
        <trigger
            name="PlayerTaunt"
            match="^From somewhere nearby, you hear (.*?) shout ridiculous insults at the Sea King.$"
            enabled="y"
            group="SKDA"
            regexp="y"
            send_to="12"
            ignore_case="y"
            sequence="100"
            script="PlayerTaunt"
        />
    
        <!-- Trigger FOR SUCCESFUL TAUNT -->
        <trigger
            name="SelfTaunt"
            match="^You shout ridiculous insults at the Sea King, whose face reddens with rage.$"
            enabled="y"
            group="SKDA"
            regexp="y"
            send_to="12"
            ignore_case="y"
            sequence="100"
            script="SelfTaunt"
        />
    
        <!-- Trigger for BAD MOONLIGHT REPORT -->
        <trigger
            name="BadMLTrigger"
            match=".*moonlight.*caresses your cheek.*"
            enabled="n"
            group="SKDA"
            regexp="y"
            send_to="12"
            ignore_case="n"
            sequence="100"
            script="BadMLTrigger"
        />
    
        <!-- Trigger for GOOD MOONLIGHT REPORT -->
        <trigger
            name="AutoGoodMLTrigger"
            match="^.*Shimmering moonlight floats through the cracks in the ceiling to grace the floor.$"
            enabled="n"
            group="SKDA"
            regexp="y"
            send_to="12"
            ignore_case="y"
            sequence="100"
            script="AutoGoodMLTrigger"
        />
    
        <!-- Triggers for HEAL PHASE -->
    
        <!-- Trigger for HEAL PHASE CONFIRM -->
        <trigger
            name="ConfirmHealPhase"
            match="^His eyes begin to glow red, and you feel your soul start to pull away from your body.$"
            enabled="y"
            group="SKDA"
            regexp="y"
            send_to="12"
            ignore_case="y"
            sequence="100"
            script="ConfirmHealPhase"
        />
    
        <!-- Trigger for HEAL ROUND -->
        <trigger
            name="VisionBlurringTrigger"
            match="^Your vision blurs as something rips at your soul!$"
            enabled="y"
            group="SKDA"
            regexp="y"
            send_to="12"
            ignore_case="y"
            sequence="100"
            script="VisionBlurringTrigger"
        />
    
        <!-- Triggers for PHASE ANNOUNCEMENTS -->
    
        <!-- Trigger for PHASE START PYLON/HEAL -->
        <trigger
            name="PhaseStartTrigger"
            match="^The Sea King leaps away, clinging to the ceiling overhead.$"
            enabled="y"
            group="SKDA"
            regexp="y"
            send_to="12"
            ignore_case="y"
            sequence="100"
            script="PhaseStartTrigger"
        />
    
        <!-- Trigger for PHASE START TAUNT/KILL -->
        <trigger
            name="TauntPhaseTrigger"
            match="^The Sea King drops back down to the floor and glances over the wreckage.$"
            enabled="y"
            group="SKDA"
            regexp="y"
            send_to="12"
            ignore_case="y"
            sequence="100"
            script="TauntPhaseTrigger"
        />
    
        <!-- Trigger for KILL PHASE -->
        <trigger
            name="KillPhaseTrigger"
            match="^The Sea King staggers, exhausted.$"
            enabled="y"
            group="SKDA"
            regexp="y"
            send_to="12"
            ignore_case="y"
            sequence="100"
            script="KillPhaseTrigger"
        />
   
        <!-- Trigger for PHASE START END -->
        <trigger
            name="PhaseEndTrigger"
            match="^Your spirit rallies as the battle continues!$"
            enabled="y"
            group="SKDA"
            regexp="y"
            send_to="12"
            ignore_case="y"
            sequence="100"
            script="PhaseEndTrigger"
        />
    
        <!-- Trigger for EPIC STATUS -->
    
        <!-- Trigger for SKD START -->
        <trigger
            name="TreasuryEntryTrigger"
            match="^With some effort, you silently pry it open and step forth into the treasury.$"
            enabled="y"
            group="SKDA"
            regexp="y"
            send_to="12"
            ignore_case="y"
            sequence="100"
            script="TreasuryEntryTrigger"
        />
    
        <!-- Trigger for SKD START other -->
        <trigger
            name="TreasuryEntryOtherTrigger"
            match="^.* pries the door to the treasury open and steps into the great room.$"
            enabled="y"
            group="SKDA"
            regexp="y"
            send_to="12"
            ignore_case="y"
            sequence="100"
            script="TreasuryEntryOtherTrigger"
        />
    
        <!-- Generic Trigger for PLAYER DEATH -->
        <trigger
            name="PlayerDeathTrigger"
            match="^INFO:.*"
            enabled="y"
            group="SKDA"
            regexp="y"
            send_to="12"
            ignore_case="y"
            sequence="100"
            script="PlayerDeathTrigger"
        />
    
        <!-- Trigger for SKD FINISH -->
        <trigger
            name="RichesTrigger"
            match="^Around you are piles of riches - heaps of gold, uncountable gems.$"
            enabled="y"
            group="SKDA"
            regexp="y"
            send_to="12"
            ignore_case="y"
            sequence="100"
            script="RichesTrigger"
        />
    
        <!-- SKD REWARDS -->
        <trigger
            match="^Spectre of the Deep says, &quot;A parting gift - at least until the brat gets up again\.&quot;$"
            name="activateRewards"
            enabled="y"
            group="SKDA"
            omit_from_output="n"
            regexp="y"
            sequence="100"
            script="activateRewards"
        />
    
        <trigger
            match="^Spectre of the Deep says, &quot;Farewell\.&quot;$"
            name="reportRewards"
            enabled="n"
            group="SKDA"
            omit_from_output="n"
            regexp="y"
            sequence="100"
            script="reportRewards"
        />
    
        <trigger
            match="^You are awarded (?<trains>\d+|\d{1,3}(,\d{3})*)(\.\d+)? trains and (?<gold>\d+|\d{1,3}(,\d{3})*)(\.\d+)? gold\.$"
            name="rewardedGoldTrains"
            enabled="n"
            group="SKDA"
            omit_from_output="n"
            regexp="y"
            sequence="100"
            script="processRewards"
        />
    
        <trigger
            match="^You receive (?<qp>\d+|\d{1,3}(,\d{3})*)(\.\d+)? quest points\.$"
            name="rewardedQP"
            enabled="n"
            group="SKDA"
            omit_from_output="n"
            regexp="y"
            sequence="100"
            script="processRewards"
        />
    
        <trigger
            match="^You receive (?<item>.*) from Spectre of the Deep\.$"
            name="rewardedItem"
            enabled="n"
            group="SKDA"
            omit_from_output="n"
            regexp="y"
            sequence="100"
            script="processRewards"
        />
		
    </triggers>
    
    <!--  Script for the functions -->   
    <script>
        <![CDATA[	
		
        ----------------------- Plugin Update Code -----------------------
        -- Code taken from Durel's dinv plugin, originally via Crowley
        require("wait")
        require("async")
        json = require("json")
	    
        plugin_url = "https://raw.githubusercontent.com/st3rv1s/SKDAssistant/refs/heads/main/SKDAssistant.xml"
        SetVariable("DownloadURL", plugin_url)
        plugin_protocol = "HTTPS"
        plugin_prefix = "[SKDAssistant]"
        
        function update_check_alias()
            update_plugin("check")
            ColourNote("white", "", plugin_prefix .. " Checking for updated version...")
        end
        
        function update_install_alias()
            update_plugin("install")
            ColourNote("white", "", plugin_prefix .. " Checking for and installing updated version...")
        end
        
        function reload_plugin()
            local scriptPrefix = GetAlphaOption("script_prefix")
            local retval
        
            -- If the user has not already specified the script prefix for this version of mush, pick a
            -- reasonable default value
            if (scriptPrefix == "") then
                scriptPrefix = "\\\\\\"
                SetAlphaOption("script_prefix", scriptPrefix)
            end
        
            -- Tell mush to reload the plugin in one second.  We can't do it directly here because a
            -- plugin can't unload itself.  Even if it could, how could it tell mush to load it again
            -- if it weren't installed? 
            retval = Execute(scriptPrefix.."DoAfterSpecial(0.1, \"ReloadPlugin('"..GetPluginID().."')\", sendto.script)")
        end
        
        function update_plugin(mode)
            update_mode = mode
        
            wait.make(get_plugin_file)
        end
        
        function get_plugin_file()
            local urlThread = async.request(plugin_url, plugin_protocol)
        
            if not urlThread then
                note_error("Couldn't create async url request.")
                return
            end
        
            local timeout = 10
            local totTime = 0
            while (urlThread:alive() and totTime < timeout) do
                wait.time(0.1)
                totTime = totTime + 0.1
            end
        
            local remoteRet, pluginData, status, headers, fullStatus = urlThread:join()
        
            if not status then
                ColourNote("red", "", plugin_prefix .. " Couldn't download plugin file. No status code.")
                
                return
            end
        
            if (status ~= 200) then
                ColourNote("red", "", plugin_prefix .. " Plugin file request status code: " .. status .. ": " .. fullStatus)
                return
            end
            
            local currentVersion = GetPluginInfo(GetPluginID(), 19) or 0
            local currentVerStr  = string.format("%1.3f", currentVersion)
            local remoteVerStr   = string.match(pluginData, '%s%s+version="([0-9%.]+)"')
            local remoteVersion  = tonumber(remoteVerStr or "") or 0
        
            if remoteVersion == currentVersion then
                ColourNote("white", "", plugin_prefix .. " You are running the most recent version (v" .. currentVerStr .. ")")
            elseif (remoteVersion < currentVersion) then
                ColourNote("white", "", plugin_prefix .. " You have a newer version than is publicly available. (v" .. currentVerStr .. ")")
            elseif (update_mode == "check") then
                ColourNote("white", "", plugin_prefix .. " You are running v" .. currentVerStr .. ", but there's a newer version v" .. remoteVerStr)
            elseif (update_mode == "install") then
                ColourNote("white", "", plugin_prefix .. " Updating plugin from version " .. currentVerStr .. " to version " .. remoteVerStr) 
        
                local pluginFile = GetPluginInfo(GetPluginID(), 6)
                local file = io.open(pluginFile, "wb")
                file:write(pluginData)
                file:close()
                reload_plugin()
            else
                ColourNote("red", "", plugin_prefix .. " Invalid update mode: " .. update_mode)
            end
        end
        ----------------------- End Plugin Update Code -----------------------
		
        local _SKDA = "ON"
	MinorToggle = "false"
	pylonPhaseTriggered = false
        local _Channel = "gtell"
        local _LilacWeapon = "lilacweapon"
        local _LilacDual = "lilacdual"
        local _CeruleanWeapon = "ceruleanweapon"
        local _CeruleanDual = "ceruleandual"
        local _SeafoamWeapon = "seafoamweapon"
        local _SeafoamDual = "seafoamdual"
        local _LilacSpell = "lilacspell"
        local _CeruleanSpell = "ceruleanspell"
        local _SeafoamSpell = "seafoamspell"
        local _WeaponBag = "bag"
        local _ShieldSKD = "shield"
        local _HoldSKD = "hold"
	local startTime = 0
	local endTime = 0 
						
	 require "serialize"
	 require "commas"
	 require "gmcphelper"
			       
        function OnHelp()
            world.Note(world.GetPluginInfo(world.GetPluginID(), 3))
        end
		
		-- Function to trim of beginning & ending spaces
		function trim(s)
			return s:match("^%s*(.-)%s*$")
		end
		
        -- Load the Aardwolf color functions	
        dofile(GetInfo(60) .. "aardwolf_colors.lua")
        
        -- Basic print function that supports Aardwolf, xterm, and ANSI color codes
        function cnote(string)
            AnsiNote(stylesToANSI(ColoursToStyles(string)))
        end
        
        -- SETTING THE CHANNEL
        function SetChannel(name, line, wildcards)
            _Channel = wildcards[1]
            cnote("@WSKDA now broadcasts to @C" .. _Channel .. "@w")
        end
		
        -- Function to check if the plugin is present and set the toggle state
        function checkPluginAndSetToggle()
            local plugin_id = "b555825a4a5700c35fa80780"
            local plugin_info = GetPluginInfo(plugin_id, 1) -- Check if the plugin is installed
        
            if plugin_info then
                MinorToggle = "true"
                cnote("@WPlugin with ID @c" .. plugin_id .. " @Wpresent.@w")
				cnote("@WSending notifications to @cCommunication Log@w.")
				cnote("")
            else
                MinorToggle = "false"
                cnote("@WPlugin with ID @c" .. plugin_id .. " @RNOT @Wpresent.@W")
				cnote("@WSending notifications to @cMain Window@W.@w")
				cnote("")
            end
        end
		
		checkPluginAndSetToggle()
        
        -- Define the sendMessage function
        function sendMessage(message)
            local plugin_id = "b555825a4a5700c35fa80780"
            local plugin_info = GetPluginInfo(plugin_id, 1)
            
            if plugin_info then
                CallPlugin(plugin_id, "storeFromOutside", message)
            else
                cnote(message)
            end
        end

        function ToggleSKDA()
            if _SKDA == "ON" then 
                _SKDA = "OFF"
                EnableGroup("SKDA", false)
                cnote("@WSKD Assistant is @RDISABLED@W!@Y")
				cnote("")
            elseif _SKDA == "OFF" then
                _SKDA = "ON"
                EnableGroup("SKDA", true) 
                cnote("@WSKD Assistant is @GENABLED@W!@Y")
                cnote("")
                cnote("@C+@W-------------------[@CSKD Assistant Helpfile@W]-------------------@C+@w")
                ColourNote("white", "", "", "white", "", "")
                ColourNote("lightcyan", "", "skda                - ", "white", "", "Turn on/off the plugin")
				ColourNote("lightcyan", "", "skda channel        - ", "white", "", "Set to channel: ", "cyan", "", _Channel)
                ColourNote("lightcyan", "", "skda help           - ", "white", "", "Outputs this helpfile.")
                ColourNote("white", "", "", "white", "", "")
                cnote("@C+@W-------------------[@CSKD Assistant Weapons@W]-------------------@C+@w")
                ColourNote("white", "", "", "white", "", "")
                ColourNote("lightcyan", "", "skda lilac          - ", "white", "", "Set to ID: ", "magenta", "", _LilacWeapon)
                ColourNote("lightcyan", "", "skda lilacdual      - ", "white", "", "Set to ID: ", "magenta", "", _LilacDual)
                ColourNote("lightcyan", "", "skda cerulean       - ", "white", "", "Set to ID: ", "skyblue", "", _CeruleanWeapon)
                ColourNote("lightcyan", "", "skda ceruleandual   - ", "white", "", "Set to ID: ", "skyblue", "", _CeruleanDual)
                ColourNote("lightcyan", "", "skda seafoam        - ", "white", "", "Set to ID: ", "yellow", "", _SeafoamWeapon)
                ColourNote("lightcyan", "", "skda seafoamdual    - ", "white", "", "Set to ID: ", "yellow", "", _SeafoamDual)
                ColourNote("white", "", "", "white", "", "")
                ColourNote("lightcyan", "", "skda lilacspell     - ", "white", "", "Set to ID: ", "magenta", "", _LilacSpell)
                ColourNote("lightcyan", "", "skda ceruleanspell  - ", "white", "", "Set to ID: ", "skyblue", "", _CeruleanSpell)
                ColourNote("lightcyan", "", "skda seafoamspell   - ", "white", "", "Set to ID: ", "yellow", "", _SeafoamSpell)
                ColourNote("white", "", "", "white", "", "")         
                ColourNote("lightcyan", "", "skda bag            - ", "white", "", "Set to ID: ", "hotpink", "", _WeaponBag)
                ColourNote("lightcyan", "", "skda shield         - ", "white", "", "Set to ID: ", "orangered", "", _ShieldSKD)
                ColourNote("lightcyan", "", "skda hold           - ", "white", "", "Set to ID: ", "limegreen", "", _HoldSKD)
                ColourNote("white", "", "", "white", "", "")  
                cnote("@C+@W-------------------[@CSKD Assistant Commands@W]-------------------@C+@w")
                ColourNote("white", "", "", "white", "", "")
                ColourNote("lightcyan", "", "ml                  - ", "white", "", "Broadcast the good moonlight location")
				ColourNote("lightcyan", "", "cc                  - ", "white", "", "Attack pylon after weapon swap")
                ColourNote("lightcyan", "", "fc                  - ", "white", "", "Load, aim and fire cannon to the ceiling")
                ColourNote("lightcyan", "", "fcc                 - ", "white", "", "Load, aim and fire cannon to the floor")
                ColourNote("lightcyan", "", "lizstop             - ", "white", "", "Manually stops Lizaan timer (if needed)")
                ColourNote("lightcyan", "", "pylstop             - ", "white", "", "Manually stops Pylon timer (if needed)")
                ColourNote("white", "", "", "white", "", "")
                cnote("@C+@W-------------------[@CSKD Assistant Helpfile@W]-------------------@C+@w")
                cnote("")
				checkPluginAndSetToggle()
				cnote("")
            end
        end
        
        -- SETTING THE ID FOR LILAC WEAPONS
        function SetLilac(name, line, wildcards)
            _LilacWeapon = wildcards[1]
            Note("Lilac main weapon ID has been set to: " .. _LilacWeapon)
        end
        
        function ShowLilac()
            if not _LilacWeapon then
                _LilacWeapon = "empty"
            end
            Note("Lilac main weapon ID is: " .. _LilacWeapon)
        end
        
        function SetLilacDual(name, line, wildcards)
            _LilacDual = wildcards[1]
            Note("Lilac offhand weapon ID has been set to: " .. _LilacDual)
        end
        
        function ShowLilacDual()
            if not _LilacDual then
                _LilacDual = "empty"
            end
            Note("Lilac offhand weapon ID is: " .. _LilacDual)
        end
        
        function SetLilacSpell(name, line, wildcards)
            _LilacSpell = wildcards[1]
            Note("Lilac attack ID has been set to: " .. _LilacSpell)
        end
        
        function ShowLilacSpell()
            if not _LilacSpell then
                _LilacSpell = "empty"
            end
            Note("Lilac attack ID is: " .. _LilacSpell)
        end
        
        -- SETTING THE ID FOR CERULEAN WEAPONS
        function SetCerulean(name, line, wildcards)
            _CeruleanWeapon = wildcards[1]
            Note("Cerulean main weapon ID has been set to: " .. _CeruleanWeapon)
        end
        
        function ShowCerulean()
            if not _CeruleanWeapon then
                _CeruleanWeapon = "empty"
            end
            Note("Cerulean main weapon ID is: " .. _CeruleanWeapon)
        end
        
        function SetCeruleanDual(name, line, wildcards)
            _CeruleanDual = wildcards[1]
            Note("Cerulean offhand weapon ID has been set to: " .. _CeruleanDual)
        end
        
        function ShowCeruleanDual()
            if not _CeruleanDual then
                _CeruleanDual = "empty"
            end
            Note("Cerulean offhand weapon ID is: " .. _CeruleanDual)
        end
        
        function SetCeruleanSpell(name, line, wildcards)
            _CeruleanSpell = wildcards[1]
            Note("Cerulean attack ID has been set to: " .. _CeruleanSpell)
        end
        
        function ShowCeruleanSpell()
            if not _CeruleanSpell then
                _CeruleanSpell = "empty"
            end
            Note("Cerulean attack ID is: " .. _CeruleanSpell)
        end
        
        -- SETTING THE ID FOR SEAFOAM WEAPONS
        function SetSeafoam(name, line, wildcards)
            _SeafoamWeapon = wildcards[1]
            Note("Seafoam main weapon ID has been set to: " .. _SeafoamWeapon)
        end
        
        function ShowSeafoam()
            if not _SeafoamWeapon then
                _SeafoamWeapon = "empty"
            end
            Note("Seafoam main weapon ID is: " .. _SeafoamWeapon)
        end
        
        function SetSeafoamDual(name, line, wildcards)
            _SeafoamDual = wildcards[1]
            Note("Seafoam offhand weapon ID has been set to: " .. _SeafoamDual)
        end
        
        function ShowSeafoamDual()
            if not _SeafoamDual then
                _SeafoamDual = "empty"
            end
            Note("Seafoam offhand weapon ID is: " .. _SeafoamDual)
        end
        
        function SetSeafoamSpell(name, line, wildcards)
            _SeafoamSpell = wildcards[1]
            Note("Seafoam attack ID has been set to: " .. _SeafoamSpell)
        end
        
        function ShowSeafoamSpell()
            if not _SeafoamSpell then
                _SeafoamSpell = "empty"
            end
            Note("Seafoam attack ID is: " .. _SeafoamSpell)
        end
        
        -- Set the Shield ID
        function SetShieldSKD(name, line, wildcards)
            _ShieldSKD = wildcards[1]
            Note("Shield ID has been set to: " .. _ShieldSKD)
        end
        
        -- Show the Shield ID
        function ShowShieldSKD()
            if not _ShieldSKD then
                _ShieldSKD = "empty"
            end
            Note("Shield ID is: " .. _ShieldSKD)
        end
        
        -- Set the Hold ID
        function SetHoldSKD(name, line, wildcards)
            _HoldSKD = wildcards[1]
            Note("Hold ID has been set to: " .. _HoldSKD)
        end
        
        -- Show the Hold ID
        function ShowHoldSKD()
            if not _HoldSKD then
                _HoldSKD = "empty"
            end
            Note("Hold ID is: " .. _HoldSKD)
        end
        
        -- Set the ID for the weapon bag
        function SetContainerSKD(name, line, wildcards)
            _WeaponBag = wildcards[1]
            Note("SKD bag ID has been set to: " .. _WeaponBag)
        end
        
        -- Show the weapon bag ID
        function ShowContainerSKD()
            if not _WeaponBag then
                _WeaponBag = "empty"
            end
            Note("The current bag ID is: " .. _WeaponBag)
        end
                
        -- Store pylon colors
        _lilacColors    = { ColoursToStyles("@x147")[1].textcolour }
        _ceruleanColors = { ColoursToStyles("@x075")[1].textcolour }
        _seafoamColors  = { ColoursToStyles("@x159")[1].textcolour }
         
        -- Track last pylon color
        local lastPylonColor = nil
         
        -- Helper to check if a value exists in a table
        function contains(tbl, val)
            for _, v in ipairs(tbl) do
                if v == val then return true end
            end
            return false
        end
         
        -- Handle pylon colors and weapon/spell swaps
        function PylonColorsTrigger(name, line, wildcards, styles)
            if not pylonPhaseTriggered then
                PylonPhaseTrigger(name, line, wildcards, styles)
                pylonPhaseTriggered = true
                PylonTimer()
            end
         
            -- Find the colored pylon segment
            local currentColor
            for _, s in ipairs(styles) do
                if contains(_lilacColors, s.textcolour) or
                   contains(_ceruleanColors, s.textcolour) or
                   contains(_seafoamColors, s.textcolour) then
                    currentColor = s.textcolour
                    break
                end
            end
         
            if not currentColor or currentColor == lastPylonColor then return end
            lastPylonColor = currentColor
         
            if contains(_lilacColors, currentColor) then
                local lmsg = "@C(@DSKD@C) @WDamage types for lilac crystal pylon: @MSlash@W, @MSonic@W, @MElectric@W, @MAir@W, @MHoly @Wor @MNegative@w"
                if MinorToggle == "true" then sendMessage(lmsg) else cnote(lmsg) end
                SendNoEcho("get " .. _LilacWeapon .. " " .. _WeaponBag)
                SendNoEcho("second " .. _LilacWeapon)
                SendNoEcho("get " .. _LilacDual .. " " .. _WeaponBag)
                SendNoEcho("wield " .. _LilacDual)
                SendNoEcho("alias cc " .. _LilacSpell .. " pylon")
         
            elseif contains(_ceruleanColors, currentColor) then
                local cmsg = "@C(@DSKD@C) @WDamage types for cerulean crystal pylon: @BLight@W, @BBash@W, @BEnergy@W, @BFire@W, @BAcid @Wor @BEarth@w"
                if MinorToggle == "true" then sendMessage(cmsg) else cnote(cmsg) end
                SendNoEcho("get " .. _CeruleanWeapon .. " " .. _WeaponBag)
                SendNoEcho("wield " .. _CeruleanWeapon)
                SendNoEcho("get " .. _CeruleanDual .. " " .. _WeaponBag)
                SendNoEcho("second " .. _CeruleanDual)
                SendNoEcho("alias cc " .. _CeruleanSpell .. " pylon")
         
            elseif contains(_seafoamColors, currentColor) then
                local smsg = "@C(@DSKD@C) @WDamage types for seafoam crystal pylon: @YMental@W, @YMagic@W, @YPierce@W, @YCold@W, @YShadow @Wor @YWater@w"
                if MinorToggle == "true" then sendMessage(smsg) else cnote(smsg) end
                SendNoEcho("get " .. _SeafoamWeapon .. " " .. _WeaponBag)
                SendNoEcho("wield " .. _SeafoamWeapon)
                SendNoEcho("get " .. _SeafoamDual .. " " .. _WeaponBag)
                SendNoEcho("second " .. _SeafoamDual)
                SendNoEcho("alias cc " .. _SeafoamSpell .. " pylon")
            end
        end
         
        -- Handle Pylon Spawn
        function PylonSpawnTrigger(name, line, wildcards, styles)
            -- Ensure the phase logic runs once
            if not pylonPhaseTriggered then
                PylonPhaseTrigger(name, line, wildcards, styles)
                pylonPhaseTriggered = true
                PylonTimer()
            end
         
            -- Detect color directly from the spawn line
            for i, s in ipairs(styles) do
                local str_lower = s.text:lower()
             
                if string.find(str_lower, "crystal pylon") then
                    -- Call the existing color handler
                    PylonColorsTrigger(name, line, wildcards, styles)
                    break
                end
            end
        end
        
        -- Reset the flag when necessary
        function resetPylonPhaseTriggerFlag()
            pylonPhaseTriggered = false
        end
        
        -- Confirm Pylon Phase
        function PylonPhaseTrigger(name, line, wildcards, styles)
            -- Reset triggers and reset trigger_count
            SendNoEcho(_Channel .. " @C(@DSKD@C) @MPYLON @WPhase confirmed!@Y")
            EnableTrigger("BadMLTrigger", false)
        end
        
        -- Pylon Timer and countdown logic
        local PylontimerCount = 0
        local countdownTimerPylonID = nil
        local timerIntervalsPylon = {21, 15, 21, 15, 21}  -- Intervals between countdown messages
        local msgTbl = {
            "15 @Wseconds left until pylons @REXPLODE!@Y",
            "@MPylons @Wspawned! Kill within @R36 @Wseconds! @C[@D2@W/3@C]@Y",
            "15 @Wseconds left until pylons @REXPLODE!@Y",
            "@MPylons @Wspawned! Kill within @R36 @Wseconds! @C[@D3@W/3@C]@Y",
            "15 @Wseconds left until pylons @REXPLODE!@Y"
        }
        local pylonExplosionEnabled = false
        
        function PylonTimer()
            -- Send initial message
            local pmsg = "@C(@DSKD@C) @MPylons @Wspawned! Kill within @R36 @Wseconds! @C[@D1@W/3@C]@Y" 
			
            if MinorToggle == "true" then
                sendMessage(pmsg)
            else
                cnote(pmsg)
            end		
			
            -- Start the first countdown timer
            PylontimerCount = 1
            countdownTimerPylonID = AddTimer("countdown_1", 0, 0, timerIntervalsPylon[PylontimerCount], "", timer_flag.Enabled + timer_flag.OneShot + timer_flag.Temporary, "reportStatusPylon")
        end
        
        function reportStatusPylon()
            if not countdownTimerPylonID then return end
        
            -- Ensure that msgTbl[PylontimerCount] is valid
            local countdownMessage = msgTbl[PylontimerCount]
            if not countdownMessage then
                PylontimerCount = 0
                pylonExplosionEnabled = false
                return
            end
        
            -- Send countdown message
            local pcmsg = "@C(@DSKD@C) @R" .. countdownMessage
			
            if MinorToggle == "true" then
                sendMessage(pcmsg)
            else
                cnote(pcmsg)
            end
        
            -- Manage PylonExplosion flag based on specific intervals
            if PylontimerCount == 1 or PylontimerCount == 3 then
                pylonExplosionEnabled = true
            else
                pylonExplosionEnabled = false
            end
        
            -- Set up the next timer
            if countdownTimerPylonID then
                DeleteTimer(countdownTimerPylonID)  -- Remove the previous timer
            end
        
            PylontimerCount = PylontimerCount + 1
            if PylontimerCount <= #timerIntervalsPylon then
                countdownTimerPylonID = AddTimer("countdown_" .. PylontimerCount, 0, 0, timerIntervalsPylon[PylontimerCount], "", timer_flag.Enabled + timer_flag.OneShot + timer_flag.Temporary, "reportStatusPylon")
            end
        end
        
        function PylonTimerStop()
            -- Stop any active countdown timer
            if countdownTimerPylonID then
                DeleteTimer(countdownTimerPylonID)
                countdownTimerPylonID = nil
            end
            -- Reset PylontimerCount
            PylontimerCount = 0
            pylonExplosionEnabled = false
        end
        
        function PylonExplosion()
            -- Only send the explosion message if it's enabled
            if pylonExplosionEnabled then
                local pemsg = "@C(@DSKD@C) @MPylons @Whave @REXPLODED! @WFocus on @Rkilling @Wpylons!@Y"
				
                if MinorToggle == "true" then
                    sendMessage(pemsg)
                else
                    cnote(pemsg)
                end				
				
                pylonExplosionEnabled = false
            end
        end
        
        -- Handle Cannon Spawn
        function CannonSpawnTrigger(name, line, wildcards, styles)
			EnableTrigger("BadMLTrigger", false)
			
            -- Check if PylonPhaseTrigger has been called
            if not pylonPhaseTriggered then
                PylonPhaseTrigger(name, line, wildcards, styles)
                pylonPhaseTriggered = true
            end
        
            local csmsg = "@C(@DSKD@C) @WType @Gfc @Wto aim @Gceiling @Wor @Rfcc @Wto aim @Rfloor!"
			
            if MinorToggle == "true" then
                sendMessage(csmsg)
            else
                cnote(csmsg)
            end
			
            -- Retrieve room information
            local room_num = gmcp("room.info.num")
            local room_statements = {
                ["28379"] = "NA",
                ["28380"] = "N",
                ["28381"] = "NW",
                ["28383"] = "W",
                ["28384"] = "WA",
                ["28387"] = "SW",
                ["28389"] = "S",
                ["28390"] = "SA",
                ["28388"] = "SE",
                ["28385"] = "E",
                ["28386"] = "EA",
                ["28382"] = "NE"
            }
        
            if room_num then
				-- Store the room number in a global variable
                lastCannonRoom = room_num	
			
                local statement = room_statements[room_num] or "UNKNOWN"
                local msg = "@C(@DSKD@C) @MCannon@W located at @C" .. statement .. "@Y"
        
                -- Send the message silently (no echo)
                SendNoEcho(_Channel .. " " .. msg)
        
                -- Use DoAfterSpecial to call PylonTimer after 3 seconds
                DoAfterSpecial(3, "PylonTimer()", sendto.script)
            end
        
            -- Disable the trigger after it has been triggered
            EnableTrigger("CannonReportTrigger", false)
        end
        
        -- Handle Cannon Report
        function CannonReportTrigger(name, line, wildcards, styles)
			        
            -- Disable the trigger after it has been triggered
            EnableTrigger("CannonReportTrigger", false)
            EnableTrigger("BadMLTrigger", false)
		
            -- Check if PylonPhaseTrigger has been called
            if not pylonPhaseTriggered then
                PylonPhaseTrigger(name, line, wildcards, styles)
                pylonPhaseTriggered = true
                PylonTimer()
            end
                
            -- Retrieve room information
            local room_num = gmcp("room.info.num")
            local room_statements = {
                ["28379"] = "NA",
                ["28380"] = "N",
                ["28381"] = "NW",
                ["28383"] = "W",
                ["28384"] = "WA",
                ["28387"] = "SW",
                ["28389"] = "S",
                ["28390"] = "SA",
                ["28388"] = "SE",
                ["28385"] = "E",
                ["28386"] = "EA",
                ["28382"] = "NE"
            }
        
            if room_num then
                -- Store the room number in a global variable
                lastCannonRoom = room_num			
			
                local statement = room_statements[room_num] or "UNKNOWN"
                local msg = "@C(@DSKD@C) @MCannon@W located at @C" .. statement .. "@Y"
        
                -- Send the message silently (no echo)
                SendNoEcho(_Channel .. " " .. msg)
            end
        end
        
        -- Aim and fire the cannon at the ceiling, and return to the cannon's location
        function CannonCeiling(name, line, wildcards, styles)
        
            -- Check if we have a stored cannon room location
            if lastCannonRoom then
                -- Prepare the mapper goto command in a variable
                local runTo = "mapper goto " .. lastCannonRoom
        			
        		Execute(runTo)
        		
                -- Fire the cannon
                SendNoEcho("load cannon")
                SendNoEcho("aim ceiling")
                SendNoEcho("fire cannon")
				fccmsg = "@C(@DSKD@C) @WFired at @GCEILING@W!"
				
                if MinorToggle == "true" then
                    sendMessage(fccmsg)
                else
                    cnote(fccmsg)
                end
				
            end
        end
        
        -- Function that aims and fires the cannon at the floor
        function CannonFloor(name, line, wildcards, styles)
        
            -- Check if we have a stored cannon room location
            if lastCannonRoom then
                -- Prepare the mapper goto command in a variable
                local runTo = "mapper goto " .. lastCannonRoom
        			
        		Execute(runTo)
        		
                -- Fire the cannon
                SendNoEcho("load cannon")
                SendNoEcho("aim ceiling")
                SendNoEcho("fire cannon")
                fcfmsg = "@C(@DSKD@C) @WFired at @RFLOOR@W!"
				
                if MinorToggle == "true" then
                    sendMessage(fcfmsg)
                else
                    cnote(fcfmsg)
                end
            end
        end
        
        -- Initialize trigger_count if it's nil
        if trigger_count == nil then
            trigger_count = 0
        end
        
        -- Function that checks for CANNON HIT
        function CannonHitTrigger(name, line, wildcards, styles)
            SendNoEcho(_Channel .." @C(@DSKD@C) @WCannon @GHITS @Wthe @RSea King@W!@Y")
        end
        
        -- Function that checks for CANNON DIRECT HIT
        function DirectHitTrigger(name, line, wildcards, styles)
            SendNoEcho(_Channel .. " @C(@DSKD@C) @WCannon @GDIRECTLY HITS @Wthe @RSea King@W!@Y")
        end
        
        -- Function that checks for CANNON MISS
        function CannonMissTrigger(name, line, wildcards, styles)
            SendNoEcho(_Channel .. " @C(@DSKD@C) @WCannon @RMISSES @Wthe @RSea King@W!@Y")
        end
        
        -- Function that checks for AGGRO
        function AggroTrigger(name, line, wildcards, styles)
            -- Retrieve the current room number
            local room_num = gmcp("room.info.num")
            
            -- Define room statements based on room numbers
            local room_statements = {
                ["28379"] = "NA",
                ["28380"] = "N",
                ["28381"] = "NW",
                ["28383"] = "W",
                ["28384"] = "WA",
                ["28387"] = "SW",
                ["28389"] = "S",
                ["28390"] = "SA",
                ["28388"] = "SE",
                ["28385"] = "E",
                ["28386"] = "EA",
                ["28382"] = "NE"
            }
            
            -- Retrieve enemy and enemy health percentage
            local enemy = gmcp("char.status.enemy")
            local enemypct = tonumber(gmcp("char.status.enemypct"))  -- Convert health percentage to number for comparison
            
            -- Check if enemy status and health percentage are available
            if enemy and enemy ~= "" and enemypct then
                -- Get the corresponding room statement or default to "UNKNOWN"
                local statement = room_statements[room_num] or "UNKNOWN"
                
                -- Construct the primary message
				--local msg = " @C(@DSKD@C) @R" .. enemy
                local msg = " @C(@DSKD@C) @WThe @RSea King"
                msg = msg .. " @C(@R" .. enemypct .. "%@C)@W is attacking @Rme @wat @C" .. statement .. "@Y"
                
                -- Send the primary message silently (no echo)
                SendNoEcho("gtell " .. msg)
                
                -- Check if the enemy health percentage is below 12
                if enemypct <= 12 then
                    -- Construct and send the additional message
                    local extra_msg = "@C(@DSKD@C)) @WBe ready to @Ckill @Wthe @RSea King@W!@Y"
                    SendNoEcho(_Channel .. " " .. extra_msg)
                end
            end
        end
        
        -- Function that checks for TAUNT HIT
        function TauntHitTrigger(name, line, wildcards, styles)
            reported_rooms = {}
            reported_count = 0
			EnableTrigger("BadMLTrigger", true)
			EnableTrigger("AutoGoodMLTrigger", false)
            SendNoEcho(_Channel .. " @C(@DSKD@C) @YTaunt @GHIT @Won the @RSea King@W!@Y")
        end
        
        -- Function that checks for SUCCESSFUL PLAYER TAUNT
        function PlayerTaunt(name, line, wildcards, styles)
            reported_rooms = {}
            reported_count = 0
			EnableTrigger("BadMLTrigger", true)
			EnableTrigger("AutoGoodMLTrigger", false)
        end
        
        -- Function that checks for SelfTaunt
        function SelfTaunt(name, line, wildcards, styles)
            reported_rooms = {}
            reported_count = 0
			EnableTrigger("BadMLTrigger", true)
			EnableTrigger("AutoGoodMLTrigger", false)
        end
        
        -- Function that checks for BAD MOONLIGHT REPORT
        function BadMLTrigger(name, line, wildcards, styles)
			EnableTrigger("AutoGoodMLTrigger", false)
            -- Initialize the reported rooms table and count if not already initialized
            if not reported_rooms then
                reported_rooms = {}
                reported_count = 0
            end
            
            local room_num = gmcp("room.info.num")
            local room_statements = {
                ["28379"] = "NA",
                ["28380"] = "N",
                ["28381"] = "NW",
                ["28383"] = "W",
                ["28384"] = "WA",
                ["28387"] = "SW",
                ["28389"] = "S",
                ["28390"] = "SA",
                ["28388"] = "SE",
                ["28385"] = "E",
                ["28386"] = "EA",
                ["28382"] = "NE"
            }
            
            if room_num then
                if not reported_rooms[room_num] then
                    reported_rooms[room_num] = true
                    reported_count = reported_count + 1
                    
                    local statement = room_statements[room_num] or "UNKNOWN"
                    
                    local bmmsg = "@C(@DSKD@C) @RBAD MOONLIGHT @Wat @M" .. statement .. "@Y"

                    if MinorToggle == "true" then
                        sendMessage(bmmsg)
                    else
                        cnote(bmmsg)
                    end					
                                        
                    if reported_count >= 2 then    
                        EnableTrigger("BadMLTrigger", false)
                        EnableTrigger("AutoGoodMLTrigger", true) -- Enable the AutoGoodMLTrigger after 2 bad rooms
                    end
                end
            end
        end
        
        -- AutoGoodMLTrigger function
        function AutoGoodMLTrigger(name, line, wildcards, styles)
            local room_num = gmcp("room.info.num")
            local room_details = {
                ["28379"] = { statement = "NA", connected_rooms = {"N"} },
                ["28380"] = { statement = "N", connected_rooms = {"NA", "NW", "NE"} },
                ["28381"] = { statement = "NW", connected_rooms = {"N", "W"} },
                ["28383"] = { statement = "W", connected_rooms = {"NW", "SA", "SW"} },
                ["28384"] = { statement = "WA", connected_rooms = {"W"} },
                ["28387"] = { statement = "SW", connected_rooms = {"W", "S"} },
                ["28389"] = { statement = "S", connected_rooms = {"SA", "SW", "SE"} },
                ["28390"] = { statement = "SA", connected_rooms = {"S"} },
                ["28388"] = { statement = "SE", connected_rooms = {"S", "E"} },
                ["28385"] = { statement = "E", connected_rooms = {"EA", "SE", "NE"} },
                ["28386"] = { statement = "EA", connected_rooms = {"E"} },
                ["28382"] = { statement = "NE", connected_rooms = {"N", "E"} }
            }
        
            if room_num and not reported_rooms[room_num] then
                local details = room_details[room_num]
                if not details then return end
        
                local room_statement = details.statement
                local connected_rooms = details.connected_rooms
                local formatted_connections
                local num_rooms = #connected_rooms
        
                if num_rooms == 1 then
                    formatted_connections = "@M" .. connected_rooms[1]
                elseif num_rooms == 2 then
                    formatted_connections = "@M" .. connected_rooms[1] .. " @Wor @M" .. connected_rooms[2]
                else
                    formatted_connections = "@M" .. table.concat(connected_rooms, " @W, @M", 1, num_rooms - 1) .. " @Wor @M" .. connected_rooms[num_rooms]
                end
        
                local common_prefix = "@C(@DSKD@C) "
                local msg = common_prefix .. "@GGOOD MOONLIGHT @Wat @C" .. room_statement .. "@W! "
                --local position_msg = common_prefix .. "@WPosition @RSea King @Wat " .. formatted_connections .. "@Y"
				local position_msg = "@WTank @RSea King @Wat " .. formatted_connections .. "@Y"
        
                SendNoEcho(_Channel .. " " .. msg .. position_msg)
                --SendNoEcho(_Channel .. " " .. position_msg)

        		GoodMLReport()
                EnableTrigger("AutoGoodMLTrigger", false) -- Disable the AutoGoodMLTrigger after reporting
            end
        end		
		
        -- Function that checks for GOOD MOONLIGHT REPORT and includes additional room details with color codes
        function GoodMLTrigger()
            -- Define a local table for room statements and additional details
            local room_details = {
                ["28379"] = { statement = "NA", connected_rooms = {"N"} },
                ["28380"] = { statement = "N", connected_rooms = {"NA", "NW", "NE"} },
                ["28381"] = { statement = "NW", connected_rooms = {"N", "W"} },
                ["28383"] = { statement = "W", connected_rooms = {"NW", "SA", "SW"} },
                ["28384"] = { statement = "WA", connected_rooms = {"W"} },
                ["28387"] = { statement = "SW", connected_rooms = {"W", "S"} },
                ["28389"] = { statement = "S", connected_rooms = {"SA", "SW", "SE"} },
                ["28390"] = { statement = "SA", connected_rooms = {"S"} },
                ["28388"] = { statement = "SE", connected_rooms = {"S", "E"} },
                ["28385"] = { statement = "E", connected_rooms = {"EA", "SE", "NE"} },
                ["28386"] = { statement = "EA", connected_rooms = {"E"} },
                ["28382"] = { statement = "NE", connected_rooms = {"N", "E"} }
            }
            
            -- Retrieve room information via GMCP
            local room_info = gmcp("room.info")
            
            if not room_info or not room_info.num then
                -- No room info available, return silently
                return
            end
            
            local room_num = room_info.num       -- Room number
            
            -- Check if room_num exists in the room_details table
            local details = room_details[room_num]
            if not details then
                -- Room not in the details table, do nothing
                return
            end
            
            -- Extract room details
            local room_statement = details.statement
            local connected_rooms = details.connected_rooms
            
            -- Format the list of connected rooms with color codes
            local formatted_connections
            local num_rooms = #connected_rooms
            
            if num_rooms == 1 then
                formatted_connections = "@M" .. connected_rooms[1]
            elseif num_rooms == 2 then
                formatted_connections = "@M" .. connected_rooms[1] .. " @Wor @M" .. connected_rooms[2]
            else
                formatted_connections = "@M" .. table.concat(connected_rooms, " @W, @M", 1, num_rooms - 1) .. " @Wor @M" .. connected_rooms[num_rooms]
            end
            
            -- Define the common prefix
            local common_prefix = "@C(@DSKD@C) "
            
            -- Construct the original message
            local msg = common_prefix .. "@GGOOD MOONLIGHT @Wat @C" .. room_statement .. "@W! "
            
            -- Add the additional positioning message with color codes
            --local position_msg = common_prefix .. " @WTank @RSea King @Wat " .. formatted_connections .. "@Y"
			local position_msg = "@WPosition @RSea King @Wat " .. formatted_connections .. "@Y"
            
            -- Send the messages separately
            SendNoEcho("gtell " .. msg .. position_msg)
            --SendNoEcho("gtell " .. position_msg)
        end
                
        -- Function that echoes instructions for GOOD MOONLIGHT
        function GoodMLReport(name, line, wildcards, styles)
            mgmlmsg = "@C(@DSKD@C) @WType '@Cml@W' to manually report @Ggood @Wmoonlight if it has @Rmoved@W!@w"           
            cnote(mgmlmsg)   
        end
				
        -- Function that checks for HEAL PHASE CONFIRM
        function ConfirmHealPhase(name, line, wildcards, styles)
            -- Reset the pylonPhaseTriggered flag to ensure a fresh starts
            resetPylonPhaseTriggerFlag()
            PylonTimerStop()
			
			trigger_count = 0
			
            -- Common actions for this case
            EnableTrigger("CannonReportTrigger", false)
            EnableTrigger("BadMLTrigger", false)
			EnableTrigger("AutoGoodMLTrigger", false)			
			
            SendNoEcho(_Channel .. " @C(@DSKD@C) @RHEAL @WPhase confirmed!@Y")
            SendNoEcho("map")            
        end
        
        -- Function that checks for HEAL ROUND
        function VisionBlurringTrigger(name, line, wildcards, styles)
            -- Increment trigger_count and ensure it cycles from 1 to 6
            trigger_count = (trigger_count % 6) + 1
            local phase = trigger_count
			
			local hrmsg = "@C(@DSKD@C) @RHEAL @WPhase round @C[@w" .. phase .. "@D/@W6@C]@Y"

            if MinorToggle == "true" then
                sendMessage(hrmsg)
            else
                cnote(hrmsg)
            end		
            
            -- Reset the pylonPhaseTriggered flag if counter reaches 6
            if trigger_count == 6 then
                -- Reset the pylonPhaseTriggered flag to ensure a fresh start
                resetPylonPhaseTriggerFlag()
            end
        end
        
        -- Function that checks for PHASE START PYLON/HEAL
        function PhaseStartTrigger(name, line, wildcards, styles)
            -- Reset the pylonPhaseTriggered flag to ensure a fresh start
            resetPylonPhaseTriggerFlag()
			
			reported_rooms = {}  -- Reset the reported rooms
            reported_count = 0   -- Reset the reported count
            trigger_count = 0
			
			-- Common actions for this case
            EnableTrigger("CannonReportTrigger", true)
            EnableTrigger("BadMLTrigger", false)
			EnableTrigger("AutoGoodMLTrigger", false)
            
            SendNoEcho(_Channel .. " @C(@DSKD@C) @WPhase incoming: @MPylon @Wor @RHeal@Y")
            SendNoEcho("map")
        end
        
        -- Function that checks for PHASE START TAUNT/KILL
        function TauntPhaseTrigger(name, line, wildcards, styles)
            -- Reset the pylonPhaseTriggered flag to ensure a fresh start
            resetPylonPhaseTriggerFlag()
            PylonTimerStop()
			
			reported_rooms = {}  -- Reset the reported rooms
            reported_count = 0   -- Reset the reported count
            trigger_count = 0
			
			-- Common actions for this case
            EnableTrigger("CannonReportTrigger", false)
			EnableTrigger("BadMLTrigger", true)
			EnableTrigger("AutoGoodMLTrigger", false)
            
            SendNoEcho(_Channel .. " @C(@DSKD@C) @WPhase incoming: @YTaunt @Wor @CKILL@W! @RSHIELD UP!@Y")
            SendNoEcho("get " .. _ShieldSKD .. " " .. _WeaponBag)
            SendNoEcho("wear " .. _ShieldSKD)
            SendNoEcho("get " .. _HoldSKD .. " " .. _WeaponBag)
            SendNoEcho("wear " .. _HoldSKD)
            SendNoEcho("map")
        end
		
        function KillPhaseTrigger()
            -- Retrieve enemy status and health percentage
            local enemyKill = gmcp("char.status.enemy")
            local enemypctKillStr = gmcp("char.status.enemypct")  -- Retrieve as a string
            local enemypctKill = tonumber(enemypctKillStr)  -- Convert health percentage to number
        	
        	local room_num = gmcp("room.info.num")
            local room_statements = {
                ["28379"] = "NA",
                ["28380"] = "N",
                ["28381"] = "NW",
                ["28383"] = "W",
                ["28384"] = "WA",
                ["28387"] = "SW",
                ["28389"] = "S",
                ["28390"] = "SA",
                ["28388"] = "SE",
                ["28385"] = "E",
                ["28386"] = "EA",
                ["28382"] = "NE"
            }
        
            -- If there's no enemy or if the health percentage is invalid, do nothing
            if not enemyKill or not enemypctKill then
                return
            end
            
            -- Get the corresponding room statement or default to "UNKNOWN"
            local statement = room_statements[room_num] or "UNKNOWN"
        
            -- Construct the primary message
            local msg = "@C(@DSKD@C) @WKill the @RSea King"
            msg = msg .. " @C(@R" .. enemypctKill .. "%@C)@W at @C" .. statement .. " @WNOW!@Y"
        
            -- Send the message silently (no echo)
            SendNoEcho("gtell " .. msg)
        
            -- Disable the trigger to prevent it from firing again
            EnableTrigger("KillPhaseTrigger", false)
        end
        
        -- Global variable to store the player's name
        playerName = ""
		
        function startTimer()
           startTime = os.clock()
        end	

        function endTimer()
           endTime = os.clock() - startTime
        end		
        
        -- Function to handle SKD Start
        function TreasuryEntryTrigger(name, line, wildcards, styles)
			startTimer()
			
            -- Reset the pylonPhaseTriggered flag to ensure a fresh start
            resetPylonPhaseTriggerFlag()
			           
            -- Reset triggers and trigger_count
            reported_rooms = {}  -- Reset the reported rooms
            reported_count = 0   -- Reset the reported count			
            trigger_count = 0
			
			EnableTrigger("KillPhaseTrigger", true)
            EnableTrigger("CannonReportTrigger", true)
			EnableTrigger("BadMLTrigger", true)
			EnableTrigger("AutoGoodMLTrigger", false)
            EnableTrigger("VisionBlurringTrigger", true)
            
            -- Send message indicating the epic has started
            SendNoEcho("autoassist off")
            SendNoEcho("nofollow")
            SendNoEcho(_Channel .. " @C(@DSKD@C) @WEpic has @Gstarted@W. Good luck and enjoy!@Y")
        end
        
        -- Function to handle SKD Start Other
        function TreasuryEntryOtherTrigger(name, line, wildcards, styles)
			startTimer()
			
            -- Reset the pylonPhaseTriggered flag to ensure a fresh start
            resetPylonPhaseTriggerFlag()
			
			reported_rooms = {}  -- Reset the reported rooms
            reported_count = 0   -- Reset the reported count
			trigger_count = 0
			
			EnableTrigger("KillPhaseTrigger", true)
            EnableTrigger("CannonReportTrigger", true)
			EnableTrigger("BadMLTrigger", true)
			EnableTrigger("AutoGoodMLTrigger", false)
            EnableTrigger("VisionBlurringTrigger", true)
                       
            -- Send message indicating the epic has started
            SendNoEcho("autoassist off")
            SendNoEcho("nofollow")			
            SendNoEcho(_Channel .. " @C(@DSKD@C) @WEpic has @Gstarted@W. Good luck and enjoy!@Y")
        end
		
        -- Function that checks for PHASE END
        function PhaseEndTrigger(name, line, wildcards, styles)
            -- Reset the pylonPhaseTriggered flag to ensure a fresh start
            resetPylonPhaseTriggerFlag()
            PylonTimerStop()
            		
            -- Reset triggers and trigger_count
			reported_rooms = {}  -- Reset the reported rooms
            reported_count = 0   -- Reset the reported count
			trigger_count = 0
			
			EnableTrigger("KillPhaseTrigger", true)
            EnableTrigger("CannonReportTrigger", false)
			EnableTrigger("BadMLTrigger", true)
			EnableTrigger("AutoGoodMLTrigger", false)
        end
        
        -- Function to handle PLAYER DEATH
        function PlayerDeathTrigger(name, line, wildcards, styles)
			endTimer()
            -- Retrieve player's name using GMCP
            playerName = gmcp("char.base.name")
		
            -- Check if the line contains both the player's name and "the Sea King"
            if playerName and line:match(playerName) and (line:match("the Sea King") or line:match("crystal pylon") or line:match("Lizaan")) then
                LizaanTimerStop()
                PylonTimerStop()
				
                -- Reset triggers and trigger_count
				reported_rooms = {}  -- Reset the reported rooms
                reported_count = 0   -- Reset the reported count
				trigger_count = 0
				
                EnableTrigger("KillPhaseTrigger", true)
				EnableTrigger("CannonReportTrigger", false)
				EnableTrigger("BadMLTrigger", false)
				EnableTrigger("AutoGoodMLTrigger", false)
				EnableTrigger("LizaanTrigger", true) 
                
                -- Handle the player death message
                SendNoEcho(_Channel .. " @C(@DSKD@C) @WI am @RDEAD@W! Better luck next time.@Y")
                SendNoEcho("autoassist on")
                SendNoEcho("nofollow")
            end
        end
        
        -- Function that checks for SKD Finish
        function RichesTrigger(name, line, wildcards, styles)
            endTimer()
            
            -- Calculate minutes and seconds
            local minutes = math.floor(endTime / 60)
            local seconds = math.floor(endTime % 60)
			local timeString
			if minutes > 0 then
				timeString = string.format("@C%d@Wm and @C%d@Ws", minutes, seconds)
			else
				timeString = string.format("@C%d@Ws", seconds)
			end
			
            -- Reset the pylonPhaseTriggered flag to ensure a fresh start
            resetPylonPhaseTriggerFlag()
			PylonTimerStop()
			
            -- Reset triggers and trigger_count
			reported_rooms = {}  -- Reset the reported rooms
            reported_count = 0   -- Reset the reported count
			trigger_count = 0
	
            EnableTrigger("KillPhaseTrigger", true)
			EnableTrigger("CannonReportTrigger", false)
			EnableTrigger("BadMLTrigger", false)
			EnableTrigger("AutoGoodMLTrigger", false)
			EnableTrigger("LizaanTrigger", true) 			
            
            -- Handle the riches message
            SendNoEcho(_Channel .. " @C(@DSKD@C) @WThe @RSea King @Wis @RDEAD @Wafter " .. timeString .. "! @GBOW @Wto receive plunder!@Y")
            SendNoEcho("autoassist on")
            SendNoEcho("nofollow")
        end
        
        -- Function to initialize rewards
        function init_rewards()
            reward = {
                gold = 0,
                trains = 0,
                qp = 0,
                items = {}
            }
        end
        
        -- Function to activate reward triggers
        function activateRewards(name, line, wildcards, styles)
            init_rewards()
            EnableTrigger("rewardedGoldTrains", true)
            EnableTrigger("rewardedQP", true)
            EnableTrigger("rewardedItem", true)
            EnableTrigger("reportRewards", true)
            EnableTrigger("activateRewards", false)
        end
        
        -- Function to report rewards
        function reportRewards(name, line, wildcards, styles)
            EnableTrigger("rewardedGoldTrains", false)
            EnableTrigger("rewardedQP", false)
            EnableTrigger("rewardedItem", false)
            EnableTrigger("reportRewards", false)
            EnableTrigger("activateRewards", true)
            
            local rewards = print_rewards(reward)
            SendNoEcho(("%s %s"):format("gt", rewards))
        end
        
        -- Function to process rewards
        function processRewards(name, line, wildcards, styles)
            if name == "rewardedGoldTrains" then
                local rgold = string.gsub(wildcards.gold, ",", "")
                local rtrain = string.gsub(wildcards.trains, ",", "")
                reward.gold = reward.gold + tonumber(rgold)
                reward.trains = reward.trains + tonumber(rtrain)
            elseif name == "rewardedQP" then
                reward.qp = reward.qp + tonumber(wildcards.qp)
            elseif name == "rewardedItem" then
                -- Ensure that color codes are preserved in item names
                local coloredLine = StylesToColoursOneLine(styles)
                local start_idx = string.find(coloredLine, "You receive") + 12
                local end_idx = string.find(coloredLine, " from") - 1
                local item_with_codes = string.sub(coloredLine, start_idx, end_idx)
                
                -- Remove leading/trailing spaces (if any) and update count
                item_with_codes = string.match(item_with_codes, "^%s*(.-)%s*$")
                
                if reward.items[item_with_codes] then
                    reward.items[item_with_codes] = reward.items[item_with_codes] + 1
                else
                    reward.items[item_with_codes] = 1
                end
            end
        end
        
        -- Function to format numbers with commas
        function format_number(n)
            local formatted = tostring(n)
            while true do
                formatted, k = string.gsub(formatted, "^(-?%d+)(%d%d%d)", '%1,%2')
                if k == 0 then
                    break
                end
            end
            return formatted
        end
        
        -- Function to print the formatted rewards
        function print_rewards(reward)
            local result = "@C(@DSKD@C) @WThe @CSpectre of the Deep @Wrewarded me"
            local parts = {}
            
            if reward.gold > 0 then
                local formatted_gold = format_number(reward.gold)
                table.insert(parts, "@Y" .. formatted_gold .. " @Wgold")
            end
            
            if reward.trains > 0 then
                table.insert(parts, "@G" .. reward.trains .. " @Wtrains")
            end
            
            if reward.qp > 0 then
                table.insert(parts, "@C" .. reward.qp .. " @WQP")
            end
            
            if next(reward.items) then
                local item_parts = {}
                for item, count in pairs(reward.items) do
                    if count > 1 then
                        -- Apply coloring: Number in red, 'x' in white, no space between
                        local count_part = "@R" .. count .. "@Wx"
                        table.insert(item_parts, count_part .. " " .. item)
                    else
                        table.insert(item_parts, item)
                    end
                end
                local items_part = "these items: " .. table.concat(item_parts, ", ")
                table.insert(parts, items_part)
            end
            
            if #parts == 0 then
                result = result .. " nothing"
            else
                if #parts == 1 then
                    result = result .. " " .. parts[1]
                else
                    result = result .. " " .. table.concat(parts, ", ", 1, #parts - 1) .. " and " .. parts[#parts]
                end
            end
            
            result = result .. "@W.@Y"
            return result
        end
        
        -- Initialize variables
        local LizaantimerCount = 0
        local countdownTimerLizaanID = nil
        local timerIntervalsLizaan = {30, 30, 15}  -- Intervals between countdown messages
        
        function LizaanTimer()
            -- Check if a timer is already running and cancel it if necessary
            if countdownTimerLizaanID then
                DeleteTimer(countdownTimerLizaanID)
                countdownTimerLizaanID = nil
                LizaantimerCount = 0
            end
        	
            -- Send initial message
            SendNoEcho(_Channel .. " @C(@DSKD@C) @MLizaan @Wspawned! @R90 @Wseconds until she @REXPLODES@W!@Y")
            
            -- Start the first countdown timer
            LizaantimerCount = 1
            countdownTimerLizaanID = AddTimer(
                "countdown_1", 
                0, 
                0, 
                timerIntervalsLizaan[LizaantimerCount], 
                "", 
                timer_flag.Enabled + timer_flag.OneShot + timer_flag.Temporary, 
                "reportStatus"
            )

			-- Disable the trigger to prevent it from executing again
			EnableTrigger("LizaanTrigger", false)
        end
        
        function reportStatus()
            if not countdownTimerLizaanID then 
                return 
            end
        
            -- Define message table
            local msgTbl = {
                "60",
                "30",
                "15"
            }
            
            -- Get Lizaan's health percentage
            local pctLizaan = gmcp("char.status.enemypct") or "unknown"
            
            -- Check if LizaantimerCount is valid
            if LizaantimerCount > #timerIntervalsLizaan then               
                LizaantimerCount = 0
                return
            end
            
            -- Ensure that msgTbl[LizaantimerCount] is valid
            local countdownMessage = msgTbl[LizaantimerCount]
            if not countdownMessage then
                LizaantimerCount = 0
                return
            end
            
            -- Send countdown message with Lizaan's health percentage
            SendNoEcho(_Channel .. " @C(@DSKD@C) @R" .. countdownMessage .. " @Wseconds until @MLizaan @W(@R" .. pctLizaan .. "%@W) will @REXPLODE@W!")
            
            -- Set up the next timer
            if countdownTimerLizaanID then
                DeleteTimer(countdownTimerLizaanID)  -- Remove the previous timer
            end
            
            LizaantimerCount = LizaantimerCount + 1
            if LizaantimerCount <= #timerIntervalsLizaan then
                countdownTimerLizaanID = AddTimer(
                    "countdown_" .. LizaantimerCount, 
                    0, 
                    0, 
                    timerIntervalsLizaan[LizaantimerCount], 
                    "", 
                    timer_flag.Enabled + timer_flag.OneShot + timer_flag.Temporary, 
                    "reportStatus"
                )
            end
        end
		
		function LizaanExplosion()
		    -- Notifcation that we were too slow killing Lizaan
			lzemsg = "@C(@DSKD@C) @WToo late... @MLizaan @Whas @REXPLODED!@Y"

            if MinorToggle == "true" then
                sendMessage(lzemsg)
            else
                cnote(lzemsg)
            end		
		end			
        
        function LizaanTimerStop()
            -- Stop any active countdown timer
            if countdownTimerLizaanID then
                DeleteTimer(countdownTimerLizaanID)
                countdownTimerLizaanID = nil
                end
    			
            -- Reset LizaantimerCount
            LizaantimerCount = 0
			
			-- Re-enable the trigger
			EnableTrigger("LizaanTrigger", true)	
        end
        
        function OnPluginInstall()
        OnHelp()
			_Channel = GetVariable("Save_Channel") or "gtell"
            _LilacWeapon = GetVariable("Save_LilacWeapon") or "empty"
            _LilacDual = GetVariable("Save_LilacDual") or "empty"
            _CeruleanWeapon = GetVariable("Save_CeruleanWeapon") or "empty"
            _CeruleanDual = GetVariable("Save_CeruleanDual") or "empty"
            _SeafoamWeapon= GetVariable("Save_SeafoamWeapon") or "empty"
            _SeafoamDual = GetVariable("Save_SeafoamDual") or "empty"
            _LilacSpell = GetVariable("Save_LilacSpell") or "empty"
            _CeruleanSpell = GetVariable("Save_CeruleanSpell") or "empty"
            _SeafoamSpell = GetVariable("Save_SeafoamSpell") or "empty"
            _WeaponBag = GetVariable("Save_WeaponBag") or "empty"
            _ShieldSKD = GetVariable("Save_ShieldSKD") or "empty"
            _HoldSKD = GetVariable("Save_HoldSKD") or "empty"   
        end  
        
        function OnPluginSaveState()
			SetVariable("Save_Channel", _Channel)
            SetVariable("Save_LilacWeapon", _LilacWeapon)
            SetVariable("Save_LilacDual", _LilacDual)
            SetVariable("Save_CeruleanWeapon", _CeruleanWeapon)
            SetVariable("Save_CeruleanDual", _CeruleanDual)
            SetVariable("Save_SeafoamWeapon", _SeafoamWeapon)
            SetVariable("Save_SeafoamDual", _SeafoamDual)
            SetVariable("Save_LilacSpell", _LilacSpell)
            SetVariable("Save_CeruleanSpell", _CeruleanSpell)	 
            SetVariable("Save_SeafoamSpell", _SeafoamSpell)
            SetVariable("Save_WeaponBag", _WeaponBag)
            SetVariable("Save_ShieldSKD", _ShieldSKD)
            SetVariable("Save_HoldSKD", _HoldSKD)
        end
        
        ]]>
    </script>

</muclient>

